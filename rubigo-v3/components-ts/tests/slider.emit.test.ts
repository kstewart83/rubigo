/**
 * Slider Emit Callback Tests
 * AUTO-GENERATED by rubigo-build â€“ do not edit
 * 
 * Tests that actions emit callbacks with correct payload when context changes.
 * Pattern: When action mutates context.X, callback onXChange should fire with new value.
 */

import { test, expect, describe } from 'bun:test';
import { useSlider } from '../slider/solid/useSlider';

/**
 * Emit Callback Tests
 */
describe('Slider Emit Callbacks', () => {
    test('onValueChange is called when value changes via incrementValue', () => {
        let callbackFired = false;
        let callbackValue: unknown;
        
        const hook = useSlider({
            onValueChange: (value: unknown) => {
                callbackFired = true;
                callbackValue = value;
            },
        });
        
        // Invoke the action that mutates context.value
        if (typeof hook.incrementValue === 'function') {
            hook.incrementValue();
        } else if (typeof hook.triggerProps === 'function') {
            // Fallback: try triggerProps().onClick if direct method not found
            const props = hook.triggerProps();
            if (props && typeof props.onClick === 'function') {
                props.onClick();
            }
        }
        
        // The callback SHOULD have fired with the new context value
        expect(callbackFired).toBe(true);
    });

    test('onDragStart is called when dragging changes via startDrag', () => {
        let callbackFired = false;
        let callbackValue: unknown;
        
        const hook = useSlider({
            onDragStart: (value: unknown) => {
                callbackFired = true;
                callbackValue = value;
            },
        });
        
        // Invoke the action that mutates context.dragging
        if (typeof hook.startDrag === 'function') {
            hook.startDrag();
        } else if (typeof hook.triggerProps === 'function') {
            // Fallback: try triggerProps().onClick if direct method not found
            const props = hook.triggerProps();
            if (props && typeof props.onClick === 'function') {
                props.onClick();
            }
        }
        
        // The callback SHOULD have fired with the new context value
        expect(callbackFired).toBe(true);
    });

    test('onDragEnd is called when dragging changes via endDrag', () => {
        let callbackFired = false;
        let callbackValue: unknown;
        
        const hook = useSlider({
            onDragEnd: (value: unknown) => {
                callbackFired = true;
                callbackValue = value;
            },
        });
        
        // Invoke the action that mutates context.dragging
        if (typeof hook.endDrag === 'function') {
            hook.endDrag();
        } else if (typeof hook.triggerProps === 'function') {
            // Fallback: try triggerProps().onClick if direct method not found
            const props = hook.triggerProps();
            if (props && typeof props.onClick === 'function') {
                props.onClick();
            }
        }
        
        // The callback SHOULD have fired with the new context value
        expect(callbackFired).toBe(true);
    });

    test('onValueCommit is called when dragging changes via endDrag', () => {
        let callbackFired = false;
        let callbackValue: unknown;
        
        const hook = useSlider({
            onValueCommit: (value: unknown) => {
                callbackFired = true;
                callbackValue = value;
            },
        });
        
        // Invoke the action that mutates context.dragging
        if (typeof hook.endDrag === 'function') {
            hook.endDrag();
        } else if (typeof hook.triggerProps === 'function') {
            // Fallback: try triggerProps().onClick if direct method not found
            const props = hook.triggerProps();
            if (props && typeof props.onClick === 'function') {
                props.onClick();
            }
        }
        
        // The callback SHOULD have fired with the new context value
        expect(callbackFired).toBe(true);
    });

});
