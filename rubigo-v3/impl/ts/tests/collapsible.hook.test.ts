/**
 * Collapsible Hook Test: useCollapsible conformance and prop cycling
 * AUTO-GENERATED by rubigo-build – do not edit
 */

import { test, expect, describe } from 'bun:test';
import { readFileSync, existsSync } from 'fs';
import { join } from 'path';
import { createSignal, createRoot } from 'solid-js';
import { useCollapsible } from '../collapsible/solid/useCollapsible';

interface UnifiedVectors {
    component: string;
    scenarios: Array<{
        name: string;
        source: 'yaml' | 'itf';
        steps: Array<{
            event: string;
            before: { context: Record<string, unknown>; state: string };
            after: { context: Record<string, unknown>; state: string };
        }>;
    }>;
}

function loadVectors(): UnifiedVectors | null {
    const vectorsPath = join(process.cwd(), '..', 'generated', 'test-vectors', 'collapsible.unified.json');
    if (!existsSync(vectorsPath)) {
        console.warn(`No unified vectors found at ${vectorsPath}`);
        return null;
    }
    return JSON.parse(readFileSync(vectorsPath, 'utf-8'));
}

describe('Collapsible Hook Conformance', () => {
    const vectors = loadVectors();

    if (!vectors) {
        test.skip('No vectors available - run just unify-vectors first', () => { });
        return;
    }

    test('loads unified vectors', () => {
        expect(vectors.component).toBe('collapsible');
        expect(vectors.scenarios.length).toBeGreaterThan(0);
    });
});

/**
 * Prop Cycling Tests
 * 
 * These tests verify that boolean props can be cycled multiple times
 * on the SAME hook instance without state corruption.
 */
describe('Collapsible Prop Cycling', () => {
    test('open cycling: false→true→false→true (same instance)', () => {
        createRoot((dispose) => {
            const [props, setProps] = createSignal({ open: false });
            const hook = useCollapsible(() => props());
            
            expect(hook.open()).toBe(false);
            setProps({ open: true });
            expect(hook.open()).toBe(true);
            setProps({ open: false });
            expect(hook.open()).toBe(false);
            setProps({ open: true });
            expect(hook.open()).toBe(true);
            
            dispose();
        });
    });

    test('disabled cycling: false→true→false→true (same instance)', () => {
        createRoot((dispose) => {
            const [props, setProps] = createSignal({ disabled: false });
            const hook = useCollapsible(() => props());
            
            expect(hook.disabled()).toBe(false);
            setProps({ disabled: true });
            expect(hook.disabled()).toBe(true);
            setProps({ disabled: false });
            expect(hook.disabled()).toBe(false);
            setProps({ disabled: true });
            expect(hook.disabled()).toBe(true);
            
            dispose();
        });
    });

});

/**
 * Event Dispatch Tests
 */
describe('Collapsible Event Dispatch', () => {
    test('toggle() method exists and is callable', () => {
        const hook = useCollapsible({});
        expect(typeof hook.toggle).toBe('function');
    });

    test('open() method exists and is callable', () => {
        const hook = useCollapsible({});
        expect(typeof hook.open).toBe('function');
    });

    test('close() method exists and is callable', () => {
        const hook = useCollapsible({});
        expect(typeof hook.close).toBe('function');
    });

});

/**
 * Accessor Reactivity Tests
 */
describe('Collapsible Accessor Reactivity', () => {
    test('open() accessor returns boolean', () => {
        const hook = useCollapsible({});
        expect(typeof hook.open()).toBe('boolean');
    });

    test('disabled() accessor returns boolean', () => {
        const hook = useCollapsible({});
        expect(typeof hook.disabled()).toBe('boolean');
    });

});
