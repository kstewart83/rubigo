//! Button Component Scaffold
//!
//! AUTO-GENERATED by rubigo-build - LLM fills in implementation
//!
//! This is a scaffold with method stubs. Run tests and iterate until passing.

use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;

/// Button context - the extended state (internal, not exposed to JS)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct ButtonContext {
    /// Whether button is disabled
    pub disabled: bool,
    /// Whether async operation is in progress
    pub loading: bool,
    /// Whether button is currently pressed down
    pub pressed: bool,
    /// Whether button has visual focus
    pub focused: bool,
}

impl ButtonContext {
    pub fn new() -> Self {
        Self {
            disabled: false,
            loading: false,
            pressed: false,
            focused: false,
        }
    }
}

/// Button component
#[wasm_bindgen]
pub struct Button {
    context: ButtonContext,
    state: String,
}

#[wasm_bindgen]
impl Button {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        Self {
            context: ButtonContext::new(),
            state: "idle".to_string(),
        }
    }

    // === Getters ===

    #[wasm_bindgen(getter)]
    pub fn state_name(&self) -> String {
        self.state.clone()
    }

    /// Get context as JSON string (for JS interop)
    #[wasm_bindgen(getter)]
    pub fn context_json(&self) -> String {
        serde_json::to_string(&self.context).unwrap_or_default()
    }

    // === Actions ===

    /// Emit click/activation event
    pub fn trigger_action(&mut self) -> bool {
        // Emits: ["onClick"]
        if self.context.disabled || self.context.loading {
            return false;
        }
        true // Would trigger onClick callback
    }

    /// Set pressed state to true
    pub fn set_pressed_true(&mut self) -> bool {
        if self.context.disabled || self.context.loading {
            return false;
        }
        self.context.pressed = true;
        self.state = "pressed".to_string();
        true
    }

    /// Set pressed state to false
    pub fn set_pressed_false(&mut self) -> bool {
        self.context.pressed = false;
        self.state = "idle".to_string();
        true
    }

    /// Start loading state
    pub fn set_loading_true(&mut self) -> bool {
        self.context.loading = true;
        self.context.pressed = false;
        self.state = "loading".to_string();
        true
    }

    /// End loading state
    pub fn set_loading_false(&mut self) -> bool {
        self.context.loading = false;
        self.state = "idle".to_string();
        true
    }

    pub fn set_focused(&mut self) -> bool {
        self.context.focused = true;
        true
    }

    pub fn clear_focused(&mut self) -> bool {
        self.context.focused = false;
        true
    }

    /// Reset all context to initial values
    pub fn reset_context(&mut self) -> bool {
        self.context = ButtonContext::new();
        self.state = "idle".to_string();
        true
    }
}

impl Default for Button {
    fn default() -> Self {
        Self::new()
    }
}

// === Test Module ===
// Tests are in a separate file for clean separation
#[cfg(test)]
#[path = "tests.rs"]
mod tests;

fn main() {}
