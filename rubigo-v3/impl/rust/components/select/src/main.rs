//! Select Component Scaffold
//!
//! AUTO-GENERATED by rubigo-build - LLM fills in implementation
//!
//! This is a scaffold with method stubs. Run tests and iterate until passing.

use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;

/// Select context - the extended state (internal, not exposed to JS)
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct SelectContext {
    /// Currently selected option value
    pub selected_value: String,
    /// Currently highlighted option value
    pub highlighted_value: String,
    /// Whether dropdown is open
    pub open: bool,
    /// Whether select is disabled
    pub disabled: bool,
}

impl SelectContext {
    pub fn new() -> Self {
        Self {
            selected_value: "option-0".to_string(),
            highlighted_value: "option-0".to_string(),
            open: false,
            disabled: false,
        }
    }
}

/// Select component
#[wasm_bindgen]
pub struct Select {
    context: SelectContext,
    state: String,
}

#[wasm_bindgen]
impl Select {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        Self {
            context: SelectContext::new(),
            state: "idle".to_string(),
        }
    }

    // === Getters ===

    #[wasm_bindgen(getter)]
    pub fn state_name(&self) -> String {
        self.state.clone()
    }

    /// Get context as JSON string (for JS interop)
    #[wasm_bindgen(getter)]
    pub fn context_json(&self) -> String {
        serde_json::to_string(&self.context).unwrap_or_default()
    }

    // === Actions ===

    /// Open the dropdown and sync highlight to selected
    pub fn open_menu(&mut self) -> bool {
        if self.context.disabled {
            return false;
        }
        self.context.open = true;
        self.context.highlighted_value = self.context.selected_value.clone();
        self.state = "open".to_string();
        true
    }

    /// Close the dropdown
    pub fn close_menu(&mut self) -> bool {
        self.context.open = false;
        self.state = "closed".to_string();
        true
    }

    /// Select the highlighted option and close
    pub fn select_option(&mut self) -> bool {
        self.context.selected_value = self.context.highlighted_value.clone();
        self.context.open = false;
        self.state = "selected".to_string();
        true
    }

    /// Highlight the next option in the list
    pub fn highlight_next(&mut self) -> bool {
        // Simple increment: option-0 -> option-1 -> option-2
        if let Some(num) = self
            .context
            .highlighted_value
            .strip_prefix("option-")
            .and_then(|s| s.parse::<i32>().ok())
        {
            self.context.highlighted_value = format!("option-{}", (num + 1).min(2));
        }
        true
    }

    /// Highlight the previous option in the list
    pub fn highlight_prev(&mut self) -> bool {
        if let Some(num) = self
            .context
            .highlighted_value
            .strip_prefix("option-")
            .and_then(|s| s.parse::<i32>().ok())
        {
            self.context.highlighted_value = format!("option-{}", (num - 1).max(0));
        }
        true
    }

    /// Highlight the first option
    pub fn highlight_first(&mut self) -> bool {
        self.context.highlighted_value = "option-0".to_string();
        true
    }

    /// Highlight the last option
    pub fn highlight_last(&mut self) -> bool {
        self.context.highlighted_value = "option-2".to_string();
        true
    }
}

impl Default for Select {
    fn default() -> Self {
        Self::new()
    }
}

// === Test Module ===
// Tests are in a separate file for clean separation
#[cfg(test)]
#[path = "tests.rs"]
mod tests;

fn main() {}
