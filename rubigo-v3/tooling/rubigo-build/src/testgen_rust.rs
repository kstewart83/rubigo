//! Rust Test Generation Utilities
//!
//! Generates Rust test files from component specifications.
//! These tests validate the Rust/WASM component implementations.

use std::collections::HashMap;

/// Component naming configuration for Rust
/// Maps lowercase component name to Rust struct names
fn rust_struct_names() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("button", "Button");
    map.insert("checkbox", "Checkbox");
    map.insert("switch", "Switch");
    map.insert("input", "Input");
    map.insert("slider", "Slider");
    map.insert("tabs", "Tabs");
    map.insert("collapsible", "Collapsible");
    map.insert("togglegroup", "ToggleGroup");
    map.insert("tooltip", "Tooltip");
    map.insert("dialog", "Dialog");
    map.insert("select", "Select");
    map
}

/// Generate Rust conformance test content for a component
///
/// This generates a test module that:
/// 1. Imports the component from its crate
/// 2. Creates component instances
/// 3. Sends events by calling action methods
/// 4. Verifies context/state via JSON serialization
pub fn generate_rust_conformance_test(component: &str) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    format!(
        r#"//! {struct_name} Conformance Tests
//! AUTO-GENERATED by rubigo-build - do not edit
//!
//! Tests that the Rust {struct_name} component matches specification behavior.
//! These tests exercise the actual component implementation against spec-derived vectors.

use serde::Deserialize;
use serde_json::Value;
use std::fs;
use std::path::PathBuf;

// Import the component under test
// Note: Components are in separate binaries but share types via the lib
// For testing purposes, we re-create the component struct here
// In production, use wasm-pack to build each component as individual WASM

// === Test Vector Format ===

#[derive(Debug, Deserialize)]
struct UnifiedVectors {{
    scenarios: Vec<Scenario>,
}}

#[derive(Debug, Deserialize)]
struct Scenario {{
    name: String,
    source: String,
    steps: Vec<Step>,
}}

#[derive(Debug, Deserialize)]
struct Step {{
    event: String,
    #[serde(default)]
    payload: Option<Value>,
    before: Snapshot,
    after: Snapshot,
}}

#[derive(Debug, Deserialize)]
struct Snapshot {{
    context: Value,
    state: String,
}}

// === Helpers ===

fn project_root() -> PathBuf {{
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .to_path_buf()
}}

fn load_vectors() -> Option<UnifiedVectors> {{
    let path = project_root()
        .join("generated")
        .join("test-vectors")
        .join("{component}.unified.json");
    
    if !path.exists() {{
        eprintln!("No unified vectors found at {{:?}}. Run: just unify-vectors", path);
        return None;
    }}
    
    let content = fs::read_to_string(&path)
        .expect(&format!("Failed to read vectors at {{:?}}", path));
    serde_json::from_str(&content).ok()
}}

// === Tests ===

/// Spec conformance test - validates component behavior against unified vectors
/// This test will FAIL until the component implementation is complete.
#[test]
fn conformance_{component}_spec() {{
    let vectors = match load_vectors() {{
        Some(v) => v,
        None => {{
            eprintln!("⚠️  Skipping {component} conformance: no vectors found");
            return;
        }}
    }};
    
    println!("Running {{}} {component} conformance scenarios...", vectors.scenarios.len());
    
    let mut passed = 0;
    let mut failed = 0;
    
    for scenario in &vectors.scenarios {{
        for (i, step) in scenario.steps.iter().enumerate() {{
            // The test expects:
            // 1. Component starts with step.before.context/state
            // 2. Event step.event is sent 
            // 3. Component ends with step.after.context/state
            //
            // This is a conformance CHECK - components with unimplemented!() will panic
            // and the test will report which scenarios fail.
            
            println!(
                "  [{{}}] {{}} - Step {{}}: {{}}",
                scenario.source,
                scenario.name,
                i + 1,
                step.event
            );
            
            // For now, just verify the vectors loaded correctly
            // TODO: Once components export a common trait, instantiate & call here
            passed += 1;
        }}
    }}
    
    println!("✅ Loaded {{}} scenarios, {{}} steps validated", vectors.scenarios.len(), passed);
    
    // Note: This test currently only validates vector loading.
    // Phase 3 (LLM implementation) will add actual component calls.
    // When a component is fully implemented, update this test to:
    // let mut comp = {struct_name}::new();
    // dispatch_event(&mut comp, &step.event);
    // assert_eq!(comp.context_json(), step.after.context.to_string());
}}
"#,
        struct_name = struct_name,
        component = component
    )
}

/// Generate Rust ARIA test content for a component
pub fn generate_rust_aria_test(
    component: &str,
    aria_mappings: &[(String, String, String)],
) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut tests = String::new();

    for (state, attr, value) in aria_mappings {
        tests.push_str(&format!(
            r#"
#[test]
fn aria_{attr}_in_{state}() {{
    // TODO: Create component in {state} state
    // TODO: Assert aria_attrs() contains {attr}="{value}"
    assert!(true, "ARIA test placeholder");
}}
"#,
            state = state.to_lowercase().replace(' ', "_"),
            attr = attr.replace('-', "_"),
            value = value
        ));
    }

    format!(
        r#"//! {struct_name} ARIA Conformance Tests
//! AUTO-GENERATED by rubigo-build - do not edit

{tests}
"#,
        struct_name = struct_name,
        tests = tests
    )
}

/// Generate Rust keyboard test content for a component
pub fn generate_rust_keyboard_test(component: &str, mappings: &[(String, String)]) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut tests = String::new();

    for (key, action) in mappings {
        tests.push_str(&format!(
            r#"
#[test]
fn keyboard_{key}_triggers_{action}() {{
    // TODO: Create component
    // TODO: Call keydown("{key}")
    // TODO: Assert {action} was triggered
    assert!(true, "Keyboard test placeholder");
}}
"#,
            key = key.to_lowercase().replace(' ', "_"),
            action = action
        ));
    }

    format!(
        r#"//! {struct_name} Keyboard Interaction Tests
//! AUTO-GENERATED by rubigo-build - do not edit

{tests}
"#,
        struct_name = struct_name,
        tests = tests
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_rust_conformance_test() {
        let output = generate_rust_conformance_test("button");
        assert!(output.contains("Button Conformance Tests"));
        assert!(output.contains("fn conformance_button_spec()"));
        assert!(output.contains("load_vectors()"));
    }

    #[test]
    fn test_rust_struct_names() {
        let names = rust_struct_names();
        assert_eq!(names.get("togglegroup"), Some(&"ToggleGroup"));
        assert_eq!(names.get("button"), Some(&"Button"));
    }
}
