//! Button Component Tests
//!
//! AUTO-GENERATED by rubigo-build - tests are regenerated from spec
//! DO NOT EDIT - changes will be overwritten on next build

use super::*;

// === Basic Smoke Tests ===

#[test]
fn test_new_creates_instance() {
    let comp = Button::new();
    assert_eq!(comp.state_name(), "idle");
}

#[test]
fn test_default_context() {
    let comp = Button::new();
    let ctx_json = comp.context_json();
    assert!(!ctx_json.is_empty(), "context_json should return valid JSON");
}

// === Action Dispatch Helper ===

fn dispatch_event(comp: &mut Button, event: &str) {
    match event {
            "TRIGGERACTION" => { let _ = comp.trigger_action(); }
            "SETPRESSEDTRUE" => { let _ = comp.set_pressed_true(); }
            "SETPRESSEDFALSE" => { let _ = comp.set_pressed_false(); }
            "SETLOADINGTRUE" => { let _ = comp.set_loading_true(); }
            "SETLOADINGFALSE" => { let _ = comp.set_loading_false(); }
            "SETFOCUSED" => { let _ = comp.set_focused(); }
            "CLEARFOCUSED" => { let _ = comp.clear_focused(); }
            "RESETCONTEXT" => { let _ = comp.reset_context(); }
            _ => eprintln!("Unknown event: {}", event),
    }
}

// === Spec Conformance Tests ===
// These tests exercise the component against specification-derived test vectors.
// They will FAIL with unimplemented!() until the component implementation is complete.

#[test]
fn conformance_button_spec() {
    let mut comp = Button::new();
    
    // This will call the first action method, triggering unimplemented!() 
    // until the LLM implements it.
    // Once implemented, this should be replaced with full spec conformance checks.
    
    // Dispatch first event to trigger failure on unimplemented components
    let first_event = get_first_event();
    if !first_event.is_empty() {
        dispatch_event(&mut comp, first_event);
    }
    
    // Verify we can read context
    let ctx_json = comp.context_json();
    assert!(!ctx_json.is_empty(), "context_json should return valid JSON");
}

/// Returns the first event for this component (used to trigger unimplemented)
fn get_first_event() -> &'static str {
    "TRIGGERACTION"
}
