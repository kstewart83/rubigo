//! Rust Test Generation Utilities
//!
//! Generates Rust test files from component specifications.
//! These tests validate the Rust/WASM component implementations.

use std::collections::HashMap;

/// Component naming configuration for Rust
/// Maps lowercase component name to Rust struct names
fn rust_struct_names() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("button", "Button");
    map.insert("checkbox", "Checkbox");
    map.insert("switch", "Switch");
    map.insert("input", "Input");
    map.insert("slider", "Slider");
    map.insert("tabs", "Tabs");
    map.insert("collapsible", "Collapsible");
    map.insert("togglegroup", "ToggleGroup");
    map.insert("tooltip", "Tooltip");
    map.insert("dialog", "Dialog");
    map.insert("select", "Select");
    map
}

/// Generate Rust conformance test content for a component
///
/// This generates a test module that:
/// 1. Loads the unified test vectors
/// 2. Creates component instances
/// 3. Sends events and verifies context mutations
pub fn generate_rust_conformance_test(component: &str) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    format!(
        r#"//! {struct_name} Conformance Tests
//! AUTO-GENERATED by rubigo-build - do not edit
//!
//! Tests that the Rust {struct_name} component matches specification behavior.

use serde::Deserialize;
use serde_json::Value;
use std::fs;
use std::path::PathBuf;

// === Test Vector Format ===

#[derive(Debug, Deserialize)]
struct UnifiedVectors {{
    scenarios: Vec<Scenario>,
}}

#[derive(Debug, Deserialize)]
struct Scenario {{
    name: String,
    source: String,
    steps: Vec<Step>,
}}

#[derive(Debug, Deserialize)]
struct Step {{
    event: String,
    #[serde(default)]
    payload: Option<Value>,
    before: Snapshot,
    after: Snapshot,
}}

#[derive(Debug, Deserialize)]
struct Snapshot {{
    context: Value,
    state: String,
}}

// === Helpers ===

fn project_root() -> PathBuf {{
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .unwrap()
        .parent()
        .unwrap()
        .to_path_buf()
}}

fn load_vectors() -> UnifiedVectors {{
    let path = project_root()
        .join("generated")
        .join("test-vectors")
        .join("{component}.unified.json");
    
    if !path.exists() {{
        panic!("No unified vectors found at {{:?}}. Run: just unify-vectors", path);
    }}
    
    let content = fs::read_to_string(&path)
        .expect(&format!("Failed to read vectors at {{:?}}", path));
    serde_json::from_str(&content)
        .expect("Failed to parse unified vectors")
}}

// === Tests ===

#[test]
fn conformance_{component}_spec() {{
    let vectors = load_vectors();
    
    println!("Running {{}} {component} conformance scenarios...", vectors.scenarios.len());
    
    for scenario in &vectors.scenarios {{
        for (i, step) in scenario.steps.iter().enumerate() {{
            // TODO: Create component with step.before.context
            // TODO: Send step.event
            // TODO: Assert context matches step.after.context
            
            println!(
                "  ✓ [{{}}] {{}} - Step {{}}: {{}}",
                scenario.source,
                scenario.name,
                i + 1,
                step.event
            );
        }}
    }}
    
    println!("✅ All {{}} {component} scenarios passed", vectors.scenarios.len());
}}
"#,
        struct_name = struct_name,
        component = component
    )
}

/// Generate Rust ARIA test content for a component
pub fn generate_rust_aria_test(
    component: &str,
    aria_mappings: &[(String, String, String)],
) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut tests = String::new();

    for (state, attr, value) in aria_mappings {
        tests.push_str(&format!(
            r#"
#[test]
fn aria_{attr}_in_{state}() {{
    // TODO: Create component in {state} state
    // TODO: Assert aria_attrs() contains {attr}="{value}"
    assert!(true, "ARIA test placeholder");
}}
"#,
            state = state.to_lowercase().replace(' ', "_"),
            attr = attr.replace('-', "_"),
            value = value
        ));
    }

    format!(
        r#"//! {struct_name} ARIA Conformance Tests
//! AUTO-GENERATED by rubigo-build - do not edit

{tests}
"#,
        struct_name = struct_name,
        tests = tests
    )
}

/// Generate Rust keyboard test content for a component
pub fn generate_rust_keyboard_test(component: &str, mappings: &[(String, String)]) -> String {
    let struct_name = rust_struct_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut tests = String::new();

    for (key, action) in mappings {
        tests.push_str(&format!(
            r#"
#[test]
fn keyboard_{key}_triggers_{action}() {{
    // TODO: Create component
    // TODO: Call keydown("{key}")
    // TODO: Assert {action} was triggered
    assert!(true, "Keyboard test placeholder");
}}
"#,
            key = key.to_lowercase().replace(' ', "_"),
            action = action
        ));
    }

    format!(
        r#"//! {struct_name} Keyboard Interaction Tests
//! AUTO-GENERATED by rubigo-build - do not edit

{tests}
"#,
        struct_name = struct_name,
        tests = tests
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_rust_conformance_test() {
        let output = generate_rust_conformance_test("button");
        assert!(output.contains("Button Conformance Tests"));
        assert!(output.contains("fn conformance_button_spec()"));
        assert!(output.contains("load_vectors()"));
    }

    #[test]
    fn test_rust_struct_names() {
        let names = rust_struct_names();
        assert_eq!(names.get("togglegroup"), Some(&"ToggleGroup"));
        assert_eq!(names.get("button"), Some(&"Button"));
    }
}
