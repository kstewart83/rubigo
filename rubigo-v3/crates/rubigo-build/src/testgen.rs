//! Test generation utilities
//!
//! Generates TypeScript test files from component metadata and specs.

use crate::extraction::ComponentMeta;
use std::collections::HashMap;

/// Component naming configuration
/// Maps lowercase component name to Pascal case for imports
fn pascal_case_names() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("button", "Button");
    map.insert("checkbox", "Checkbox");
    map.insert("switch", "Switch");
    map.insert("input", "Input");
    map.insert("slider", "Slider");
    map.insert("tabs", "Tabs");
    map.insert("collapsible", "Collapsible");
    map.insert("togglegroup", "ToggleGroup");
    map.insert("tooltip", "Tooltip");
    map.insert("dialog", "Dialog");
    map.insert("select", "Select");
    map
}

/// Event mappings per component (only methods exposed in hook return)
fn event_mappings() -> HashMap<&'static str, Vec<(&'static str, &'static str)>> {
    let mut map = HashMap::new();
    map.insert(
        "button",
        vec![
            ("click", "click"),
            ("startLoading", "startLoading"),
            ("stopLoading", "stopLoading"),
        ],
    );
    map.insert(
        "checkbox",
        vec![
            ("toggle", "toggle"),
            ("setChecked", "setChecked"),
            ("setUnchecked", "setUnchecked"),
            ("setIndeterminate", "setIndeterminate"),
        ],
    );
    map.insert("switch", vec![("toggle", "toggle")]);
    map.insert("input", vec![]);
    map.insert(
        "slider",
        vec![
            ("increment", "increment"),
            ("decrement", "decrement"),
            ("setMin", "setMin"),
            ("setMax", "setMax"),
        ],
    );
    map.insert(
        "tabs",
        vec![
            ("selectTab", "selectTab"),
            ("focusNext", "focusNext"),
            ("focusPrev", "focusPrev"),
        ],
    );
    map.insert(
        "collapsible",
        vec![("toggle", "toggle"), ("open", "open"), ("close", "close")],
    );
    map.insert("togglegroup", vec![("select", "select")]);
    map.insert("tooltip", vec![("show", "show"), ("hide", "hide")]);
    map.insert("dialog", vec![("open", "open"), ("close", "close")]);
    map.insert("select", vec![("open", "open"), ("close", "close")]);
    map
}

/// Generate hook test file content for a component
pub fn generate_hook_tests(component: &str, meta: &ComponentMeta) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);
    let events = event_mappings().get(component).cloned().unwrap_or_default();

    // Get boolean props for cycling tests
    let boolean_props: Vec<_> = meta
        .props
        .iter()
        .filter(|p| p.prop_type == "boolean" && p.optional)
        .collect();

    let all_boolean_props: Vec<_> = meta
        .props
        .iter()
        .filter(|p| p.prop_type == "boolean")
        .collect();

    let mut output = format!(
        r#"/**
 * {pascal} Hook Test: use{pascal} conformance and prop cycling
 * AUTO-GENERATED by rubigo-build – do not edit
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ readFileSync, existsSync }} from 'fs';
import {{ join }} from 'path';
import {{ createSignal, createRoot }} from 'solid-js';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

interface UnifiedVectors {{
    component: string;
    scenarios: Array<{{
        name: string;
        source: 'yaml' | 'itf';
        steps: Array<{{
            event: string;
            before: {{ context: Record<string, unknown>; state: string }};
            after: {{ context: Record<string, unknown>; state: string }};
        }}>;
    }}>;
}}

function loadVectors(): UnifiedVectors | null {{
    const vectorsPath = join(process.cwd(), '..', 'generated', 'test-vectors', '{component}.unified.json');
    if (!existsSync(vectorsPath)) {{
        console.warn(`No unified vectors found at ${{vectorsPath}}`);
        return null;
    }}
    return JSON.parse(readFileSync(vectorsPath, 'utf-8'));
}}

describe('{pascal} Hook Conformance', () => {{
    const vectors = loadVectors();

    if (!vectors) {{
        test.skip('No vectors available - run just unify-vectors first', () => {{ }});
        return;
    }}

    test('loads unified vectors', () => {{
        expect(vectors.component).toBe('{component}');
        expect(vectors.scenarios.length).toBeGreaterThan(0);
    }});
}});

/**
 * Prop Cycling Tests
 * 
 * These tests verify that boolean props can be cycled multiple times
 * on the SAME hook instance without state corruption.
 */
describe('{pascal} Prop Cycling', () => {{
"#,
        pascal = pascal,
        component = component
    );

    // Add prop cycling tests
    if boolean_props.is_empty() {
        // No boolean props in spec - don't generate prop cycling tests
    } else {
        for prop in &boolean_props {
            output.push_str(&format!(
                r#"    test('{name} cycling: false→true→false→true (same instance)', () => {{
        createRoot((dispose) => {{
            const [props, setProps] = createSignal({{ {name}: false }});
            const hook = use{pascal}(() => props());
            
            expect(hook.{name}()).toBe(false);
            setProps({{ {name}: true }});
            expect(hook.{name}()).toBe(true);
            setProps({{ {name}: false }});
            expect(hook.{name}()).toBe(false);
            setProps({{ {name}: true }});
            expect(hook.{name}()).toBe(true);
            
            dispose();
        }});
    }});

"#,
                name = prop.name,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n\n");

    // Event dispatch tests
    output.push_str(&format!(
        r#"/**
 * Event Dispatch Tests
 */
describe('{pascal} Event Dispatch', () => {{
"#,
        pascal = pascal
    ));

    if events.is_empty() {
        // No event mappings in spec - don't generate event dispatch tests
    } else {
        for (_, method) in &events {
            output.push_str(&format!(
                r#"    test('{method}() method exists and is callable', () => {{
        const hook = use{pascal}({{}});
        expect(typeof hook.{method}).toBe('function');
    }});

"#,
                method = method,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n\n");

    // Accessor reactivity tests
    output.push_str(&format!(
        r#"/**
 * Accessor Reactivity Tests
 */
describe('{pascal} Accessor Reactivity', () => {{
"#,
        pascal = pascal
    ));

    if all_boolean_props.is_empty() {
        // No boolean props/accessors in spec - don't generate accessor tests
    } else {
        for prop in &all_boolean_props {
            output.push_str(&format!(
                r#"    test('{name}() accessor returns boolean', () => {{
        const hook = use{pascal}({{}});
        expect(typeof hook.{name}()).toBe('boolean');
    }});

"#,
                name = prop.name,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n");

    output
}

/// ARIA attribute definition from spec
#[derive(Debug, Clone)]
pub struct AriaMapping {
    pub state: String,
    pub attributes: HashMap<String, String>,
}

/// Extract ARIA mapping from spec content
pub fn extract_aria_mapping(content: &str) -> Vec<AriaMapping> {
    let mut mappings = Vec::new();
    let mut in_aria_block = false;
    let mut lines: Vec<&str> = Vec::new();

    for line in content.lines() {
        if line.trim() == "```aria-mapping" {
            in_aria_block = true;
            lines.clear();
            continue;
        }

        if in_aria_block && line.trim() == "```" {
            break;
        }

        if in_aria_block {
            lines.push(line);
        }
    }

    if lines.len() < 3 {
        return mappings;
    }

    // Parse header row to get attribute names
    let header: Vec<&str> = lines[0]
        .trim()
        .trim_start_matches('|')
        .trim_end_matches('|')
        .split('|')
        .map(|s| s.trim())
        .collect();

    // Skip divider row (lines[1])

    // Parse data rows
    for line in lines.iter().skip(2) {
        let cells: Vec<&str> = line
            .trim()
            .trim_start_matches('|')
            .trim_end_matches('|')
            .split('|')
            .map(|s| s.trim())
            .collect();

        if cells.len() >= header.len() {
            let state = cells[0].to_string();
            let mut attributes = HashMap::new();

            for (i, attr_name) in header.iter().enumerate().skip(1) {
                if i < cells.len() {
                    attributes.insert(attr_name.to_string(), cells[i].to_string());
                }
            }

            mappings.push(AriaMapping { state, attributes });
        }
    }

    mappings
}

/// Generate component ARIA conformance test file
pub fn generate_component_tests(component: &str, aria_mappings: &[AriaMapping]) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    // Collect unique attribute names
    let mut attr_names: Vec<String> = aria_mappings
        .iter()
        .flat_map(|m| m.attributes.keys().cloned())
        .collect();
    attr_names.sort();
    attr_names.dedup();

    let mut output = format!(
        r#"/**
 * {pascal} Component ARIA Conformance Tests
 * AUTO-GENERATED by rubigo-build – do not edit
 * 
 * Tests that rootProps() returns correct ARIA attributes per state.
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

/**
 * ARIA Conformance Tests
 */
describe('{pascal} ARIA Conformance', () => {{
    test('rootProps() returns object with ARIA attributes', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect(typeof props).toBe('object');
    }});

"#,
        pascal = pascal,
        component = component
    );

    for attr in &attr_names {
        output.push_str(&format!(
            r#"    test('rootProps() includes {attr}', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect('{attr}' in props).toBe(true);
    }});

"#,
            attr = attr,
            pascal = pascal
        ));
    }

    output.push_str("});\n");

    output
}

/// Keyboard interaction mapping
#[derive(Debug, Clone)]
pub struct KeyboardMapping {
    pub key: String,
    pub description: String,
}

/// Extract keyboard mappings from interactions (component name -> mappings)
pub fn parse_keyboard_interactions(
    interactions_json: &str,
) -> HashMap<String, Vec<KeyboardMapping>> {
    let mut result = HashMap::new();

    // Parse JSON
    let json: serde_json::Value = match serde_json::from_str(interactions_json) {
        Ok(v) => v,
        Err(_) => return result,
    };

    // Navigate to components
    if let Some(components) = json.get("components").and_then(|c| c.as_object()) {
        for (name, component) in components {
            if let Some(keyboard) = component.get("keyboard").and_then(|k| k.as_object()) {
                let mappings: Vec<KeyboardMapping> = keyboard
                    .iter()
                    .map(|(key, desc)| KeyboardMapping {
                        key: key.clone(),
                        description: desc.as_str().unwrap_or("").to_string(),
                    })
                    .collect();
                result.insert(name.clone(), mappings);
            }
        }
    }

    result
}

/// Generate keyboard interaction tests for a component
pub fn generate_keyboard_tests(component: &str, mappings: &[KeyboardMapping]) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut output = format!(
        r#"/**
 * {pascal} Keyboard Interaction Tests
 * AUTO-GENERATED by rubigo-build – do not edit
 * 
 * Tests that keyboard handlers are present and work correctly.
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

/**
 * Keyboard Handler Tests
 * 
 * Verify rootProps() includes keyboard event handlers.
 */
describe('{pascal} Keyboard Interactions', () => {{
    test('rootProps() includes onKeyDown handler', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect(typeof props.onKeyDown).toBe('function');
    }});

"#,
        pascal = pascal,
        component = component
    );

    // Add test for each keyboard mapping
    for mapping in mappings {
        // Skip compound keys like "Space/Enter" or "Tab/Shift+Tab"
        if mapping.key.contains('/') || mapping.key.contains('+') {
            continue;
        }

        // Skip special keys that are just descriptions
        if mapping.key.contains(' ') {
            continue;
        }

        output.push_str(&format!(
            r#"    test('{key} key is documented: {desc}', () => {{
        // This test documents expected behavior for {key}
        // Actual keyboard handling is tested via component integration tests
        const hook = use{pascal}({{}});
        expect(hook.rootProps).toBeDefined();
    }});

"#,
            key = mapping.key,
            desc = mapping.description.replace('\'', "\\'"),
            pascal = pascal
        ));
    }

    output.push_str("});\n");

    output
}

/// Emit mapping: action name -> (mutated context prop, emit callback name, mutation string)
#[derive(Debug, Clone)]
pub struct EmitMapping {
    pub action_name: String,
    pub context_prop: String,
    pub emit_name: String,
    pub mutation: String,
}

impl EmitMapping {
    /// Check if this action is idempotent (setter) or non-idempotent (toggle/delta)
    /// Idempotent actions should only fire callbacks on actual state change
    pub fn is_idempotent(&self) -> bool {
        // Toggle pattern: = !context.X (negation/flip)
        if self.mutation.contains("= !context.") || self.mutation.contains("=!context.") {
            return false;
        }
        // Delta pattern: X + context.Y or X - context.Y (additive/relative)
        if self.mutation.contains("+ context.") || self.mutation.contains("- context.") {
            return false;
        }
        // Everything else (= true, = false, = literal) is idempotent
        true
    }

    /// Check if this action requires setup before testing
    /// Actions that reset state to false (e.g., endDrag sets dragging=false) need
    /// the corresponding start action to be called first
    pub fn requires_setup(&self) -> bool {
        // Reset to false pattern: context.X = false
        // The initial state is typically false, so calling this action without setup won't fire
        self.mutation.contains("= false")
    }
}

/// Extract emit mappings from spec content by parsing Actions section
/// Returns list of (action, context_prop, emit_name) tuples
pub fn extract_emit_mappings(content: &str) -> Vec<EmitMapping> {
    let mut mappings = Vec::new();

    // Find the Actions section
    let actions_start = content.find("## Actions");
    if actions_start.is_none() {
        return mappings;
    }

    // Find the CUE block within Actions
    let after_actions = &content[actions_start.unwrap()..];
    let cue_start = after_actions.find("```cue");
    let cue_end = after_actions.find("```\n");

    if cue_start.is_none() || cue_end.is_none() {
        return mappings;
    }

    let cue_content = &after_actions[cue_start.unwrap() + 6..cue_end.unwrap()];

    // Parse CUE actions to find mutation/emits pairs
    // Format: actionName: { mutation: "context.X = ...", emits: ["onXChange"] }
    let mut current_action = String::new();
    let mut current_context_prop: Option<String> = None;
    let mut current_mutation = String::new();
    let mut current_emits: Vec<String> = Vec::new();

    for line in cue_content.lines() {
        let trimmed = line.trim();

        // Detect action start (word followed by colon and brace)
        if !trimmed.starts_with("actions:")
            && !trimmed.starts_with("//")
            && !trimmed.starts_with("mutation")
            && !trimmed.starts_with("description")
            && !trimmed.starts_with("emits")
            && !trimmed.starts_with("}")
            && !trimmed.is_empty()
            && trimmed.contains(":")
        {
            // Save previous action if we have both mutation and emit
            if !current_action.is_empty()
                && current_context_prop.is_some()
                && !current_emits.is_empty()
            {
                for emit in &current_emits {
                    mappings.push(EmitMapping {
                        action_name: current_action.clone(),
                        context_prop: current_context_prop.clone().unwrap(),
                        emit_name: emit.clone(),
                        mutation: current_mutation.clone(),
                    });
                }
            }

            // Start new action
            current_action = trimmed.split(':').next().unwrap_or("").trim().to_string();
            current_context_prop = None;
            current_mutation.clear();
            current_emits.clear();
        }

        // Parse mutation line: mutation: "context.X = ..."
        if trimmed.starts_with("mutation:") {
            // Capture the full mutation string for idempotency detection
            if let Some(quote_start) = trimmed.find('"') {
                if let Some(quote_end) = trimmed.rfind('"') {
                    if quote_end > quote_start {
                        current_mutation = trimmed[quote_start + 1..quote_end].to_string();
                    }
                }
            }
            // Extract context.X from mutation
            if let Some(ctx_start) = trimmed.find("context.") {
                let after_ctx = &trimmed[ctx_start + 8..];
                // Find the prop name (everything up to = or whitespace)
                let prop_end = after_ctx
                    .find(|c: char| c == ' ' || c == '=')
                    .unwrap_or(after_ctx.len());
                current_context_prop = Some(after_ctx[..prop_end].to_string());
            }
        }

        // Parse emits line: emits: ["onXChange"]
        if trimmed.starts_with("emits:") {
            // Extract callback names from array
            if let Some(arr_start) = trimmed.find('[') {
                if let Some(arr_end) = trimmed.find(']') {
                    let arr_content = &trimmed[arr_start + 1..arr_end];
                    for emit in arr_content.split(',') {
                        let emit_name = emit.trim().trim_matches('"').to_string();
                        if !emit_name.is_empty() {
                            current_emits.push(emit_name);
                        }
                    }
                }
            }
        }
    }

    // Don't forget the last action
    if !current_action.is_empty() && current_context_prop.is_some() && !current_emits.is_empty() {
        for emit in &current_emits {
            mappings.push(EmitMapping {
                action_name: current_action.clone(),
                context_prop: current_context_prop.clone().unwrap(),
                emit_name: emit.clone(),
                mutation: current_mutation.clone(),
            });
        }
    }

    mappings
}

/// Generate emit callback tests for a component
pub fn generate_emit_tests(component: &str, mappings: &[EmitMapping]) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut output = format!(
        r#"/**
 * {component_title} Emit Callback Tests
 * AUTO-GENERATED by rubigo-build – do not edit
 * 
 * Tests that actions emit callbacks with correct payload when context changes.
 * Pattern: When action mutates context.X, callback onXChange should fire with new value.
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

/**
 * Emit Callback Tests
 */
describe('{component_title} Emit Callbacks', () => {{
"#,
        component_title = pascal,
        pascal = pascal,
        component = component
    );

    // Deduplicate by emit_name (one test per emit callback)
    let mut seen_emits: std::collections::HashSet<String> = std::collections::HashSet::new();

    for mapping in mappings {
        if seen_emits.contains(&mapping.emit_name) {
            continue;
        }
        seen_emits.insert(mapping.emit_name.clone());

        // All hooks now expose spec-compliant method names
        // No mappings needed - use action name directly
        let method_name = &mapping.action_name;

        // Map emit name to actual callback prop name if they differ
        // All hooks now expose spec-compliant callback names
        let callback_name = &mapping.emit_name;

        // Skip tests for actions that require setup (e.g., endDrag needs startDrag first)
        // These can't be tested without proper initial state
        if mapping.requires_setup() {
            continue;
        }

        // Generate test for this emit
        output.push_str(&format!(
            r#"    test('{emit_name} is called when {context_prop} changes via {action_name}', () => {{
        let callbackFired = false;
        let callbackValue: unknown;
        
        const hook = use{pascal}({{
            {callback_name}: (value: unknown) => {{
                callbackFired = true;
                callbackValue = value;
            }},
        }});
        
        // Invoke the action that mutates context.{context_prop}
        if (typeof hook.{method_name} === 'function') {{
            hook.{method_name}();
        }} else if (typeof hook.triggerProps === 'function') {{
            // Fallback: try triggerProps().onClick if direct method not found
            const props = hook.triggerProps();
            if (props && typeof props.onClick === 'function') {{
                props.onClick();
            }}
        }}
        
        // The callback SHOULD have fired with the new context value
        expect(callbackFired).toBe(true);
    }});

"#,
            emit_name = mapping.emit_name,
            callback_name = callback_name,
            context_prop = mapping.context_prop,
            action_name = mapping.action_name,
            method_name = method_name,
            pascal = pascal,
        ));

        // Generate idempotency test ONLY for idempotent actions (setters, not toggles/deltas)
        // Toggle actions (= !context.X) and delta actions (+ context.step) should fire on each call
        if mapping.is_idempotent() {
            output.push_str(&format!(
                r#"    test('{action_name} is idempotent - calling twice fires {emit_name} once', () => {{
        let callCount = 0;
        
        const hook = use{pascal}({{
            {callback_name}: () => {{
                callCount++;
            }},
        }});
        
        // Call the action twice
        if (typeof hook.{method_name} === 'function') {{
            hook.{method_name}();  // First call - should fire callback
            hook.{method_name}();  // Second call - state unchanged, should NOT fire
        }}
        
        // Callback should only fire once (on state change), not on redundant calls
        expect(callCount).toBe(1);
    }});

"#,
                emit_name = mapping.emit_name,
                callback_name = callback_name,
                action_name = mapping.action_name,
                method_name = method_name,
                pascal = pascal,
            ));
        }
    }

    output.push_str("});\n");

    output
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_aria_mapping() {
        let content = r#"
## ARIA Mapping

```aria-mapping
| State         | aria-checked | aria-disabled |
|---------------|--------------|---------------|
| unchecked     | false        | {disabled}    |
| checked       | true         | {disabled}    |
| indeterminate | mixed        | {disabled}    |
```
"#;
        let mappings = extract_aria_mapping(content);
        assert_eq!(mappings.len(), 3);
        assert_eq!(mappings[0].state, "unchecked");
        assert_eq!(
            mappings[0].attributes.get("aria-checked"),
            Some(&"false".to_string())
        );
    }

    #[test]
    fn test_pascal_case_togglegroup() {
        let names = pascal_case_names();
        assert_eq!(names.get("togglegroup"), Some(&"ToggleGroup"));
    }

    #[test]
    fn test_parse_keyboard_interactions() {
        let json = r#"{
            "components": {
                "button": {
                    "keyboard": {
                        "Enter": "Activate immediately",
                        "Space": "Activate on key up"
                    }
                }
            }
        }"#;
        let result = parse_keyboard_interactions(json);
        assert!(result.contains_key("button"));
        assert_eq!(result["button"].len(), 2);
    }
}
