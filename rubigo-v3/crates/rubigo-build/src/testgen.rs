//! Test generation utilities
//!
//! Generates TypeScript test files from component metadata and specs.

use crate::extraction::ComponentMeta;
use std::collections::HashMap;

/// Component naming configuration
/// Maps lowercase component name to Pascal case for imports
fn pascal_case_names() -> HashMap<&'static str, &'static str> {
    let mut map = HashMap::new();
    map.insert("button", "Button");
    map.insert("checkbox", "Checkbox");
    map.insert("switch", "Switch");
    map.insert("input", "Input");
    map.insert("slider", "Slider");
    map.insert("tabs", "Tabs");
    map.insert("collapsible", "Collapsible");
    map.insert("togglegroup", "ToggleGroup");
    map.insert("tooltip", "Tooltip");
    map.insert("dialog", "Dialog");
    map.insert("select", "Select");
    map
}

/// Event mappings per component (only methods exposed in hook return)
fn event_mappings() -> HashMap<&'static str, Vec<(&'static str, &'static str)>> {
    let mut map = HashMap::new();
    map.insert(
        "button",
        vec![
            ("click", "click"),
            ("startLoading", "startLoading"),
            ("stopLoading", "stopLoading"),
        ],
    );
    map.insert(
        "checkbox",
        vec![
            ("toggle", "toggle"),
            ("setChecked", "setChecked"),
            ("setUnchecked", "setUnchecked"),
            ("setIndeterminate", "setIndeterminate"),
        ],
    );
    map.insert("switch", vec![("toggle", "toggle")]);
    map.insert("input", vec![]);
    map.insert(
        "slider",
        vec![
            ("increment", "increment"),
            ("decrement", "decrement"),
            ("setMin", "setMin"),
            ("setMax", "setMax"),
        ],
    );
    map.insert(
        "tabs",
        vec![
            ("selectTab", "selectTab"),
            ("focusNext", "focusNext"),
            ("focusPrev", "focusPrev"),
        ],
    );
    map.insert(
        "collapsible",
        vec![("toggle", "toggle"), ("open", "open"), ("close", "close")],
    );
    map.insert("togglegroup", vec![("select", "select")]);
    map.insert("tooltip", vec![("show", "show"), ("hide", "hide")]);
    map.insert("dialog", vec![("open", "open"), ("close", "close")]);
    map.insert("select", vec![("open", "open"), ("close", "close")]);
    map
}

/// Generate hook test file content for a component
pub fn generate_hook_tests(component: &str, meta: &ComponentMeta) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);
    let events = event_mappings().get(component).cloned().unwrap_or_default();

    // Get boolean props for cycling tests
    let boolean_props: Vec<_> = meta
        .props
        .iter()
        .filter(|p| p.prop_type == "boolean" && p.optional)
        .collect();

    let all_boolean_props: Vec<_> = meta
        .props
        .iter()
        .filter(|p| p.prop_type == "boolean")
        .collect();

    let mut output = format!(
        r#"/**
 * {pascal} Hook Test: use{pascal} conformance and prop cycling
 * AUTO-GENERATED by rubigo-build – do not edit
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ readFileSync, existsSync }} from 'fs';
import {{ join }} from 'path';
import {{ createSignal, createRoot }} from 'solid-js';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

interface UnifiedVectors {{
    component: string;
    scenarios: Array<{{
        name: string;
        source: 'yaml' | 'itf';
        steps: Array<{{
            event: string;
            before: {{ context: Record<string, unknown>; state: string }};
            after: {{ context: Record<string, unknown>; state: string }};
        }}>;
    }}>;
}}

function loadVectors(): UnifiedVectors | null {{
    const vectorsPath = join(process.cwd(), '..', 'generated', 'test-vectors', '{component}.unified.json');
    if (!existsSync(vectorsPath)) {{
        console.warn(`No unified vectors found at ${{vectorsPath}}`);
        return null;
    }}
    return JSON.parse(readFileSync(vectorsPath, 'utf-8'));
}}

describe('{pascal} Hook Conformance', () => {{
    const vectors = loadVectors();

    if (!vectors) {{
        test.skip('No vectors available - run just unify-vectors first', () => {{ }});
        return;
    }}

    test('loads unified vectors', () => {{
        expect(vectors.component).toBe('{component}');
        expect(vectors.scenarios.length).toBeGreaterThan(0);
    }});
}});

/**
 * Prop Cycling Tests
 * 
 * These tests verify that boolean props can be cycled multiple times
 * on the SAME hook instance without state corruption.
 */
describe('{pascal} Prop Cycling', () => {{
"#,
        pascal = pascal,
        component = component
    );

    // Add prop cycling tests
    if boolean_props.is_empty() {
        // No boolean props in spec - don't generate prop cycling tests
    } else {
        for prop in &boolean_props {
            output.push_str(&format!(
                r#"    test('{name} cycling: false→true→false→true (same instance)', () => {{
        createRoot((dispose) => {{
            const [props, setProps] = createSignal({{ {name}: false }});
            const hook = use{pascal}(() => props());
            
            expect(hook.{name}()).toBe(false);
            setProps({{ {name}: true }});
            expect(hook.{name}()).toBe(true);
            setProps({{ {name}: false }});
            expect(hook.{name}()).toBe(false);
            setProps({{ {name}: true }});
            expect(hook.{name}()).toBe(true);
            
            dispose();
        }});
    }});

"#,
                name = prop.name,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n\n");

    // Event dispatch tests
    output.push_str(&format!(
        r#"/**
 * Event Dispatch Tests
 */
describe('{pascal} Event Dispatch', () => {{
"#,
        pascal = pascal
    ));

    if events.is_empty() {
        // No event mappings in spec - don't generate event dispatch tests
    } else {
        for (_, method) in &events {
            output.push_str(&format!(
                r#"    test('{method}() method exists and is callable', () => {{
        const hook = use{pascal}({{}});
        expect(typeof hook.{method}).toBe('function');
    }});

"#,
                method = method,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n\n");

    // Accessor reactivity tests
    output.push_str(&format!(
        r#"/**
 * Accessor Reactivity Tests
 */
describe('{pascal} Accessor Reactivity', () => {{
"#,
        pascal = pascal
    ));

    if all_boolean_props.is_empty() {
        // No boolean props/accessors in spec - don't generate accessor tests
    } else {
        for prop in &all_boolean_props {
            output.push_str(&format!(
                r#"    test('{name}() accessor returns boolean', () => {{
        const hook = use{pascal}({{}});
        expect(typeof hook.{name}()).toBe('boolean');
    }});

"#,
                name = prop.name,
                pascal = pascal
            ));
        }
    }

    output.push_str("});\n");

    output
}

/// ARIA attribute definition from spec
#[derive(Debug, Clone)]
pub struct AriaMapping {
    pub state: String,
    pub attributes: HashMap<String, String>,
}

/// Extract ARIA mapping from spec content
pub fn extract_aria_mapping(content: &str) -> Vec<AriaMapping> {
    let mut mappings = Vec::new();
    let mut in_aria_block = false;
    let mut lines: Vec<&str> = Vec::new();

    for line in content.lines() {
        if line.trim() == "```aria-mapping" {
            in_aria_block = true;
            lines.clear();
            continue;
        }

        if in_aria_block && line.trim() == "```" {
            break;
        }

        if in_aria_block {
            lines.push(line);
        }
    }

    if lines.len() < 3 {
        return mappings;
    }

    // Parse header row to get attribute names
    let header: Vec<&str> = lines[0]
        .trim()
        .trim_start_matches('|')
        .trim_end_matches('|')
        .split('|')
        .map(|s| s.trim())
        .collect();

    // Skip divider row (lines[1])

    // Parse data rows
    for line in lines.iter().skip(2) {
        let cells: Vec<&str> = line
            .trim()
            .trim_start_matches('|')
            .trim_end_matches('|')
            .split('|')
            .map(|s| s.trim())
            .collect();

        if cells.len() >= header.len() {
            let state = cells[0].to_string();
            let mut attributes = HashMap::new();

            for (i, attr_name) in header.iter().enumerate().skip(1) {
                if i < cells.len() {
                    attributes.insert(attr_name.to_string(), cells[i].to_string());
                }
            }

            mappings.push(AriaMapping { state, attributes });
        }
    }

    mappings
}

/// Generate component ARIA conformance test file
pub fn generate_component_tests(component: &str, aria_mappings: &[AriaMapping]) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    // Collect unique attribute names
    let mut attr_names: Vec<String> = aria_mappings
        .iter()
        .flat_map(|m| m.attributes.keys().cloned())
        .collect();
    attr_names.sort();
    attr_names.dedup();

    let mut output = format!(
        r#"/**
 * {pascal} Component ARIA Conformance Tests
 * AUTO-GENERATED by rubigo-build – do not edit
 * 
 * Tests that rootProps() returns correct ARIA attributes per state.
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

/**
 * ARIA Conformance Tests
 */
describe('{pascal} ARIA Conformance', () => {{
    test('rootProps() returns object with ARIA attributes', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect(typeof props).toBe('object');
    }});

"#,
        pascal = pascal,
        component = component
    );

    for attr in &attr_names {
        output.push_str(&format!(
            r#"    test('rootProps() includes {attr}', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect('{attr}' in props).toBe(true);
    }});

"#,
            attr = attr,
            pascal = pascal
        ));
    }

    output.push_str("});\n");

    output
}

/// Keyboard interaction mapping
#[derive(Debug, Clone)]
pub struct KeyboardMapping {
    pub key: String,
    pub description: String,
}

/// Extract keyboard mappings from interactions (component name -> mappings)
pub fn parse_keyboard_interactions(
    interactions_json: &str,
) -> HashMap<String, Vec<KeyboardMapping>> {
    let mut result = HashMap::new();

    // Parse JSON
    let json: serde_json::Value = match serde_json::from_str(interactions_json) {
        Ok(v) => v,
        Err(_) => return result,
    };

    // Navigate to components
    if let Some(components) = json.get("components").and_then(|c| c.as_object()) {
        for (name, component) in components {
            if let Some(keyboard) = component.get("keyboard").and_then(|k| k.as_object()) {
                let mappings: Vec<KeyboardMapping> = keyboard
                    .iter()
                    .map(|(key, desc)| KeyboardMapping {
                        key: key.clone(),
                        description: desc.as_str().unwrap_or("").to_string(),
                    })
                    .collect();
                result.insert(name.clone(), mappings);
            }
        }
    }

    result
}

/// Generate keyboard interaction tests for a component
pub fn generate_keyboard_tests(component: &str, mappings: &[KeyboardMapping]) -> String {
    let pascal = pascal_case_names()
        .get(component)
        .copied()
        .unwrap_or(component);

    let mut output = format!(
        r#"/**
 * {pascal} Keyboard Interaction Tests
 * AUTO-GENERATED by rubigo-build – do not edit
 * 
 * Tests that keyboard handlers are present and work correctly.
 */

import {{ test, expect, describe }} from 'bun:test';
import {{ use{pascal} }} from '../{component}/solid/use{pascal}';

/**
 * Keyboard Handler Tests
 * 
 * Verify rootProps() includes keyboard event handlers.
 */
describe('{pascal} Keyboard Interactions', () => {{
    test('rootProps() includes onKeyDown handler', () => {{
        const hook = use{pascal}({{}});
        const props = hook.rootProps();
        expect(typeof props.onKeyDown).toBe('function');
    }});

"#,
        pascal = pascal,
        component = component
    );

    // Add test for each keyboard mapping
    for mapping in mappings {
        // Skip compound keys like "Space/Enter" or "Tab/Shift+Tab"
        if mapping.key.contains('/') || mapping.key.contains('+') {
            continue;
        }

        // Skip special keys that are just descriptions
        if mapping.key.contains(' ') {
            continue;
        }

        output.push_str(&format!(
            r#"    test('{key} key is documented: {desc}', () => {{
        // This test documents expected behavior for {key}
        // Actual keyboard handling is tested via component integration tests
        const hook = use{pascal}({{}});
        expect(hook.rootProps).toBeDefined();
    }});

"#,
            key = mapping.key,
            desc = mapping.description.replace('\'', "\\'"),
            pascal = pascal
        ));
    }

    output.push_str("});\n");

    output
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extract_aria_mapping() {
        let content = r#"
## ARIA Mapping

```aria-mapping
| State         | aria-checked | aria-disabled |
|---------------|--------------|---------------|
| unchecked     | false        | {disabled}    |
| checked       | true         | {disabled}    |
| indeterminate | mixed        | {disabled}    |
```
"#;
        let mappings = extract_aria_mapping(content);
        assert_eq!(mappings.len(), 3);
        assert_eq!(mappings[0].state, "unchecked");
        assert_eq!(
            mappings[0].attributes.get("aria-checked"),
            Some(&"false".to_string())
        );
    }

    #[test]
    fn test_pascal_case_togglegroup() {
        let names = pascal_case_names();
        assert_eq!(names.get("togglegroup"), Some(&"ToggleGroup"));
    }

    #[test]
    fn test_parse_keyboard_interactions() {
        let json = r#"{
            "components": {
                "button": {
                    "keyboard": {
                        "Enter": "Activate immediately",
                        "Space": "Activate on key up"
                    }
                }
            }
        }"#;
        let result = parse_keyboard_interactions(json);
        assert!(result.contains_key("button"));
        assert_eq!(result["button"].len(), 2);
    }
}
